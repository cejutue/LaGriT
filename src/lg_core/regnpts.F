      subroutine regnpts(icount,imsgin,xmsgin,cmsgin,msgtype,nwds,
     *   ierr2)
C
      implicit none
C
C
C#######################################################################
C
C     PURPOSE -
C
c     This routine generates points in the requested region name.
c     The points are generated by using rays from a user specified
c     center, line or plane through a set of user supplied points
c     and finding surface interfaces for each ray within the region.
c     The point distribution is determined by the data type in PTDIST.
c     If PTDIST is integer, then that many points are distributed
c     along the ray in the region.
c
c        If PTDIST is real, then points are distributed at that distance
c     along the ray, up to a maximum of MAXPENETR points along the
c     ray (in addition to any interface points that may be created).
c     Note:  if the ray encounters a region more than once, multiple
c     sets of MAXPENTR points are layed down.
c     If MAXPENETR is not specified, the number of points distributed
c     along the ray in this manner is only limited by region
c     membership.
c
c        Only intersection points are created if PTDIST is INSIDE, IN,
c     OUT, OUTSIDE, or BOTH.  In this case, intersection points are created
c     regardless if the region owns the interfaces.
c
c        The variables IRRATIO and RRZ determine
c     ratio zoning when PTDIST is an integer value.  Ratio zoning is
c     on when IRRATIO is 1, then the distribution is ajusted by the
c     value for RRZ.  When IRRATIO is 2 then the points are distributed
c     by equal volumes depending on the geometry type.  When IRRATIO is
c     3 then ratio zoning is calculated on the longest ray, Then this
c     length distribution is applied to all the rays.
C
C
C     FORMAT: REGNPTS/REGION NAME/PTDIST/IPFIRST,IPLAST,ISTRIDE/
C                                    IGEOM/RAY ORIGIN/irratio,rrz
c /maxpenetr
C                          -OR-
C     FORMAT: REGNPTS/REGION NAME/PTDIST/pset,get,SETNAME/
C                                    IGEOM/RAY ORIGIN/irratio,rrz
c /maxpenetr
C             WHERE IPFIRST,IPLAST,ISTRIDE OR pset,get,SETNAME DETERMINE
C                   THE SET OF POINTS TO SHOOT RAYS THROUGH.
C
C      SPECIFICALLY FOR ALLOWABLE GEOMETRY TYPES:
C        REGNPTS/REGION NAME/PTDIST/IPFIRST,IPLAST,ISTRIDE/
C                          xyz/x1,y1,z1/x2,y2,z2/x3,y3,z3/irratio,rrz
c /maxpenetr
C             WHERE POINTS 1, 2, 3 DEFINE THE PLANE TO SHOOT RAYS FROM
C                   NORMAL TO THE PLANE.
C        REGNPTS/REGION NAME/PTDIST/IPFIRST,IPLAST,ISTRIDE/
C                          rtz/x1,y1,z1/x2,y2,z2/irratio,rrz/maxpenetr
C             WHERE POINTS 1, 2 DEFINE THE LINE TO SHOOT RAYS FROM
C                   PERPENDICULAR TO THE LINE.
C        REGNPTS/REGION NAME/PTDIST/IPFIRST,IPLAST,ISTRIDE/
C                          rtp/xcen,ycen,zcen/irratio,rrz/maxpenetr
C             WHERE xcen,ycen,zcen DEFINE THE CENTER OF THE SPHERE TO
C                   SHOOT RAYS FROM.
C        REGNPTS/REGION NAME/PTDIST/IPFIRST,IPLAST,ISTRIDE/
C                          points/iffirst,iflast,ifstride/irratio,rrz
c /maxpenetr
C             WHERE iffirst,iflast,ifstride DEFINE THE POINTS TO
C                   SHOOT RAYS FROM.
C
C
C     INPUT ARGUMENTS -
C
C        icount - CURRENT POINT COUNT
C        xmsgin - REAL ARRAY OF COMMAND INPUT VALUES
C        msgin - INTEGER ARRAY OF COMMAND INPUT VALUES
C        imsgin - INTEGER ARRAY OF COMMAND INPUT VALUES
C        nwds - NO. OF WORDS OF COMMAND INPUT VALUES
C
C
C
C     OUTPUT ARGUMENTS -
C
C        ierr2 - INVALID INPUT ERROR FLAG
C
C
C     CHANGE HISTORY -
C
C        $Log: regnpts.f,v $
C        Revision 2.00  2007/11/09 20:04:01  spchu
C        Import to CVS
C
CPVCS    
CPVCS       Rev 1.7   06 Nov 2003 14:00:56   gable
CPVCS    Increased format for screen output from i6 to i9.
CPVCS    
CPVCS       Rev 1.6   Fri Apr 07 10:19:22 2000   dcg
CPVCS    replace use of KNWPN for length calculation with mmgetblk type 3
CPVCS    
CPVCS       Rev 1.5   Tue Mar 21 15:47:54 2000   dcg
CPVCS    add call to setsize
CPVCS    
CPVCS       Rev 1.4   Tue Feb 15 11:15:58 2000   dcg
CPVCS    use geom_name 
CPVCS    
CPVCS       Rev 1.3   Thu Feb 03 08:56:42 2000   dcg
CPVCS    
CPVCS       Rev 1.2   13 Jan 2000 14:48:22   dcg
CPVCS    
CPVCS       Rev 1.1   05 Jan 2000 17:33:18   dcg
CPVCS     
CPVCS
CPVCS       Rev 1.49   Wed Aug 11 12:40:36 1999   dcg
CPVCS    use max of character lengths when comparing surface names
CPVCS
CPVCS       Rev 1.48   Wed Jul 07 16:08:10 1999   dcg
CPVCS    remove indirect indexing that broke sun optimized compiler
CPVCS
CPVCS       Rev 1.47   Fri Aug 28 14:25:20 1998   dcg
CPVCS    remove single precision constants
CPVCS
CPVCS       Rev 1.46   Thu May 28 22:28:58 1998   kuprat
CPVCS    Deleted incorrect comment.
CPVCS
CPVCS       Rev 1.45   Thu May 28 16:42:12 1998   kuprat
CPVCS    Fixed bug where we were incorrectly interpreting results of
CPVCS    whether interval endpoints should be part of generated point
CPVCS    set.
CPVCS
CPVCS       Rev 1.44   Tue Nov 25 10:02:16 1997   dcg
CPVCS    get correct size for temporary storage
CPVCS
CPVCS       Rev 1.42   Thu Nov 06 15:06:16 1997   kuprat
CPVCS    Changed it so that the origin plane, line, point is considered a
CPVCS    boundary for point creation purposes.  In particular, points will now
CPVCS    be automatically created (assuming region ownership) at the centers
CPVCS    of spheres or at the center axes of cylinders.
CPVCS
CPVCS       Rev 1.41   Fri Oct 31 10:49:56 1997   dcg
CPVCS    declare ipcmoprm as a pointer
CPVCS
CPVCS       Rev 1.40   Fri Oct 03 11:02:56 1997   dcg
CPVCS    reorder declarations as per DEC compiler
CPVCS
CPVCS       Rev 1.39   Tue Sep 02 23:15:46 1997   kuprat
CPVCS    Fixed bug where some 'entry' interface points were lost.
CPVCS
CPVCS       Rev 1.38   Mon Aug 18 18:19:26 1997   kuprat
CPVCS    Corrected a bug.  Due to a typo in the previous version, we were
CPVCS    effectively discarding the interval between the 'plane' and
CPVCS    the first intersection point on each ray.
CPVCS
CPVCS       Rev 1.37   Fri Jul 11 11:10:16 1997   kuprat
CPVCS    Fixed bug where projected array use with XPTDIST option
CPVCS    was incorrectly computed.
CPVCS
CPVCS       Rev 1.36   Wed Jul 02 16:34:48 1997   kuprat
CPVCS    Changed it so that MAXPENETR limitation did not force
CPVCS    placement of points at interfaces (i.e., in the case
CPVCS    when the region does not own the interface).  To force
CPVCS    placement, use PTDIST=IN, OUT, or BOTH.
CPVCS
CPVCS       Rev 1.35   Tue Jul 01 16:48:16 1997   kuprat
CPVCS    Removed logic which added a volume point at the midpoint of the
CPVCS    interval if otherwise there would be no volume points.
CPVCS    Changed treatment of MAXPENETR as follows.  If zero, only
CPVCS    'entry' interface pt added.  If positive, only 'entry'
CPVCS    interface + MAXPENETR (at most) interior pts. added.
CPVCS    Added logic for suppressing pt addition at beginning of
CPVCS    first interval, if this beginning is not a real interface,
CPVCS    but is the source (i.e., source plane, source line, etc.).
CPVCS
CPVCS       Rev 1.34   Mon Jun 30 14:24:16 1997   kuprat
CPVCS    Fixed bug that resulted in certain volume points being put in bad
CPVCS    positions.  Also, changed the code so NO volume points are added
CPVCS    in the case of REGNPTS/../0/...
CPVCS
CPVCS       Rev 1.33   Mon Apr 28 11:55:48 1997   kuprat
CPVCS    Fixed surfpts problem.
CPVCS
CPVCS       Rev 1.32   Fri Jan 31 09:34:22 1997   dcg
CPVCS    add 'nint' to fix ibm incompatible types error
CPVCS
CPVCS       Rev 1.31   Mon Jan 13 15:51:24 1997   dcg
CPVCS    replace explicit dimensioning of length 100 by
CPVCS    dynamic dimensioning
CPVCS
CPVCS       Rev 1.29   Mon Jan 06 12:25:40 1997   kuprat
CPVCS    Changed algorithm:  Intervals between surface intersections
CPVCS    are now concatenated if adjacent intervals both belong to the region in which
CPVCS    points are being distributed.  This eliminates the distribution
CPVCS    of spurious points on surfaces interior to the region.
CPVCS
CPVCS       Rev 1.28   Wed Nov 13 12:30:32 1996   kuprat
CPVCS    We now have 'penetration control', so that MAXPENETR (when
c specified)
CPVCS    limits the number of points distributed along rays (when
c spacing
CPVCS    was specified by user).
CPVCS
CPVCS       Rev 1.27   Mon Oct 28 22:44:14 1996   kuprat
CPVCS    Fixed insufficient memory bug that occurred when
CPVCS    called from surfpts.
CPVCS
CPVCS       Rev 1.26   Mon Aug 19 19:32:04 1996   kuprat
CPVCS    Switched to dynamic memory allocation for the relatively large
CPVCS    fixed length arrays SFACT and SFCT.
CPVCS
CPVCS       Rev 1.25   Wed Aug 14 14:47:58 1996   dcg
CPVCS    replace erroneous ismax call with iimax
CPVCS
CPVCS       Rev 1.24   Mon Jul 08 15:15:30 1996   kuprat
CPVCS    Rewrote about half of subroutine.  We now utilize cleaned up,
CPVCS    vectorized algorithms.
CPVCS
CPVCS       Rev 1.23   11/07/95 17:25:00   dcg
CPVCS    change flag to 2 in mmgetblk calls
CPVCS
CPVCS       Rev 1.22   09/19/95 13:10:28   dcg
CPVCS    add primative syntax checking
CPVCS
CPVCS       Rev 1.21   08/31/95 10:06:16   ahmed
CPVCS    Adjust the equation for computing interface points
CPVCS
CPVCS       Rev 1.20   08/29/95 12:03:24   dcg
CPVCS    set length for names to 40 characters
CPVCS
CPVCS       Rev 1.19   08/28/95 11:35:48   ahmed
CPVCS    Adjust the location of mmrelprt in the routine
CPVCS
CPVCS       Rev 1.18   08/23/95 16:17:36   dcg
CPVCS    changes needed for new sheet implementation
CPVCS
CPVCS       Rev 1.17   08/23/95 06:58:46   het
CPVCS    Remove the CMO prefix from SB-ids
CPVCS
CPVCS       Rev 1.16   08/22/95 06:50:46   het
CPVCS    Split the storage block for CMO variables.
CPVCS
CPVCS       Rev 1.15   07/17/95 16:02:40   dcg
CPVCS    get all volume points even if close to boundary
CPVCS
CPVCS       Rev 1.14   06/07/95 15:31:28   het
CPVCS    Change character*32 idsb to character*132 idsb
CPVCS
CPVCS       Rev 1.13   05/26/95 13:15:12   het
CPVCS    Replace subroutine parameter list with subroutine calles.
CPVCS
CPVCS       Rev 1.12   05/11/95 13:40:20   ejl
CPVCS    Fixed problem with epsln
CPVCS
CPVCS       Rev 1.11   05/01/95 08:34:04   het
CPVCS    Modifiy all the storage block calles for long names
CPVCS
CPVCS       Rev 1.10   03/31/95 09:09:34   het
CPVCS    Add the buildid calles before all storage block calls
CPVCS
CPVCS       Rev 1.9   03/30/95 05:00:42   het
CPVCS    Change the storage block id packing and preidsb to buildid for
c long names
CPVCS
CPVCS       Rev 1.8   03/28/95 12:35:28   het
CPVCS    Add the binary dumpx3d/readx3d commands and correct associated
c mm-errors.
CPVCS
CPVCS       Rev 1.7   03/23/95 15:08:10   dcg
CPVCS     Add mesh object name to storage block id for surface,region
c info.
CPVCS
CPVCS       Rev 1.6   03/17/95 21:37:32   het
CPVCS    Add Ahmeds ray routine
CPVCS
CPVCS       Rev 1.5   02/18/95 06:57:04   het
CPVCS    Changed the parameter list to be the same as pntlimc
CPVCS
CPVCS       Rev 1.4   12/19/94 08:27:22   het
CPVCS    Add the "comdict.h" include file.
CPVCS
CPVCS
CPVCS       Rev 1.3   12/06/94 19:07:18   het
CPVCS    Add the "call cmo_get_name" to return the current mesh object
c name.
CPVCS
CPVCS       Rev 1.2   12/02/94 19:47:46   het
CPVCS    Fixed a memory management error with "mpnt" and "ialias".
CPVCS
CPVCS
CPVCS       Rev 1.1   12/01/94 18:40:38   het
CPVCS    Change "cmo" calles to add data type
CPVCS    Alias the "decimate2d"  command to "decimate"
CPVCS    Alias the "settets" command to "mass"
CPVCS
CPVCS       Rev 1.0   11/10/94 12:18:12   pvcs
CPVCS    Original version.
C
C#######################################################################
C
      include "consts.h"
      include 'geom_lg.h'
      include 'machine.h'

C     args
      integer nwds, icount,ierr2
      real*8 xmsgin(nwds)
      integer imsgin(nwds),msgtype(nwds)
      character*(*) cmsgin(nwds)

C
      integer lenptr
      parameter (lenptr=1000000)

      integer ierror,npoints,length,icmotype,iout,
     &   ilen,ityp,ierr,icscode,j,
     &   idist,nptdist,ierrw,irratio,ipf1,ipf2,ipf3,iexp,ier,
     &   ics,nwrdef,i,ir,len1,len2,icharlnf,
     &   iregck,is,idefreg,ipt1,ipt2,ipt3,mpno,mpno3,
     &   nincr,ii,
     &   loopcnt,icntin,ioff,loclen,i1,ip,ipf,
     &   ivec,i2,k,newmint,nr,irz,need,ivolseq,
     &   lenivec,ireleased,iadd,iimax,len,nsrf,
     &   ivec2,maxpenetr,ivolinterval,icurrmin,icurrmax,numint,
     &   lenadd

      pointer(ipmpary1, mpary1)
      pointer(ipmpary3, mpary3)
      integer mpary1(lenptr),mpary3(lenptr)

      pointer (ipisetwd, isetwd)
      pointer (ipitp1, itp1)
      integer isetwd(lenptr), itp1(lenptr)

      pointer (ipisurfnum,isurfnum)
      integer isurfnum(100)

      pointer(ipindx2,indx2)
      pointer(ipiregloc,iregloc)
      pointer(ipisurfno,isurfno)
      pointer(ipiregno,iregno)
      pointer(ipisurfno2,isurfno2)
      pointer(ipiregno2,iregno2)
      integer iregloc(lenptr),
     &   isurfno(lenptr),iregno(lenptr),indx2(lenptr),
     &   isurfno2(lenptr),iregno2(lenptr)

C
      integer mint(KVECLEN),nsf(KVECLEN)
      real*8 xr1(KVECLEN),
     &   yr1(KVECLEN),zr1(KVECLEN),xr2(KVECLEN),yr2(KVECLEN),
     &   zr2(KVECLEN),dist(KVECLEN)

      logical lreal(KVECLEN),ladd

 
C
      real*8 xptdist,x1,y1,z1,x2,y2,z2,rrz,a,b,c,d,au,bu,cu,dista,
     &   srchval,drmax,ckmin,ckmax,x3,y3,z3,sf,s,distx,smin,smax,
     &   xstrt,ystrt,zstrt,xfin,yfin,zfin,rmin,rmax,dr,rstrt,sumf,
     &   vol1,r,ddr,rlast,rnext,sfr

      real*8 alargenumber
      parameter (alargenumber=1.0d+20)

      pointer (ipsfct,sfct)
      pointer (ipsfact,sfact)
      real*8 sfact(100,lenptr),sfct(100,lenptr)

      pointer(ipxck,xck)
      pointer(ipyck,yck)
      pointer(ipzck,zck)
      pointer(ipxadd,xadd)
      pointer(ipyadd,yadd)
      pointer(ipzadd,zadd)
      real*8 xck(lenptr),yck(lenptr),zck(lenptr),
     &   xadd(lenptr),yadd(lenptr),zadd(lenptr)

      pointer (ipxic, xic)
      pointer (ipyic, yic)
      pointer (ipzic, zic)
      real*8 xic(lenptr), yic(lenptr), zic(lenptr)
      pointer(ipout,out)
      real*8 out(*)
      real*8 rout

C
      pointer (ipisoper,isoper)
      character*32 isoper(100)

      character*32 iregnam
      character*32 cmo
      character*32 inout, igeom, ctest, ctest_old, geom_name
      character*32 cpt1, cpt2, cpt3
      character*32 cpf1, cpf2, cpf3
      character*40 isubname,isubname1
      character*132 logmess
C
C ######################################################################
C begin

      ierr2=0
      isubname='regnpts'
      isubname1='regnpts1'
      ireleased=0
C
C     ******************************************************************
C
c.... Dynamically allocate space for the large fixed length arrays
c.... SFACT and SFCT which compute s-factors over a vector of rays
c.... of length KVECLEN.  Since we must allow for many intersections
c.... between the rays and a given surface (100), the length is
c.... 100*KVECLEN for each array.  In the case of more than 100
c.... intersections, these arrays need be accordingly increased in
c.... size.
 
      length=100*KVECLEN
      call mmgetblk('sfct',isubname,ipsfct,length,2,icscode)
      call mmgetblk('sfact',isubname,ipsfact,length,2,icscode)
      length=100
      call mmgetblk('isoper',isubname,ipisoper,length,3,icscode)
      call mmgetblk('isurfnum',isubname,ipisurfnum,length,1,icscode)
 
 
      call cmo_get_name(cmo,ierror)
C
      call cmo_get_intinfo('nnodes',cmo,
     *   npoints,length,icmotype,ierror)
      call cmo_get_attinfo('geom_name',cmo,iout,rout,geom_name,
     *   ipout,ilen,ityp,ierr)
      call cmo_get_info('isetwd',cmo,ipisetwd,ilen,ityp,ierr)
      call cmo_get_info('itp1',cmo,ipitp1,ilen,ityp,ierr)
      call cmo_get_info('xic',cmo,ipxic,ilen,ityp,ierr)
      call cmo_get_info('yic',cmo,ipyic,ilen,ityp,ierr)
      call cmo_get_info('zic',cmo,ipzic,ilen,ityp,ierr)
C
C     ******************************************************************
C
C
C     ******************************************************************
C     GET THE REGION NAME AND THE DISTRIBUTION DATA
C
      iregnam=cmsgin(1)
C
      idist=0
      inout=' '
      if (msgtype(2) .eq. 1) then
         idist=1
         nptdist=imsgin(2)
      endif
      if (msgtype(2) .eq. 2) then
         idist=2
         xptdist=xmsgin(2)
      endif
      if (msgtype(2) .eq. 3) then
         idist=3
         inout=cmsgin(2)
         nptdist=1
         if (inout.eq.'both' .or. inout.eq.'b') nptdist=2
      endif
C
C     ******************************************************************
C     DETERMINE GEOMETRY TYPE AND VALIDATE.
C
      igeom=cmsgin(6)
      if (igeom(1:3).ne.'xyz' .and.
     &   igeom(1:3).ne.'rtz' .and.
     &   igeom(1:3).ne.'rtp' .and.
     &   igeom(1:6).ne.'points') then
         ierr2=1
         write(logmess,9000) igeom
 9000    format('  ERROR - INVALID GEOMETRY TYPE ',a8)
         call writloga('default',0,logmess,0,ierrw)
         go to 9999
      endif
C
      maxpenetr=-1
      irratio=0
      rrz=0.
C
C     ******************************************************************
C     GET RAY ORIGIN POINT SET FOR points.
C
      if (igeom(1:6) .eq. 'points') then
         if(msgtype(7).eq.1) then
            ipf1=imsgin(7)
            ipf2=imsgin(8)
            ipf3=imsgin(9)
         else
            cpf1=cmsgin(7)
            cpf2=cmsgin(8)
            cpf3=cmsgin(9)
         endif
         if (nwds.ge.10) then
            call test_argument_type(1,1,10,imsgin,xmsgin,cmsgin,msgtype,
     *         nwds)
            irratio=imsgin(10)
            call test_argument_type(1,2,11,imsgin,xmsgin,cmsgin,msgtype,
     *         nwds)
            rrz=xmsgin(11)
         endif
         if (idist.eq.2.and.nwds.ge.12) then
            call test_argument_type(1,1,12,imsgin,xmsgin,cmsgin,msgtype,
     *         nwds)
            maxpenetr=imsgin(12)
         endif
      endif
C
      if (igeom(1:3) .eq. 'xyz') then
C
C     ******************************************************************
C     GET RAY ORIGIN PLANE FOR xyz GEOMETRY
C
         call test_argument_type(9,2,7,imsgin,xmsgin,cmsgin,msgtype,nwds
     &      )
         x1=xmsgin(7)
         y1=xmsgin(8)
         z1=xmsgin(9)
         x2=xmsgin(10)
         y2=xmsgin(11)
         z2=xmsgin(12)
         x3=xmsgin(13)
         y3=xmsgin(14)
         z3=xmsgin(15)
C
C        ---------------------------------------------------------------
C        SET UP THE EQUATION OF THE PLANE FROM THE 3 POINTS.
C
         a=  (y2-y1)*(z3-z1) - (y3-y1)*(z2-z1)
         b=-((x2-x1)*(z3-z1) - (x3-x1)*(z2-z1))
         c=  (x2-x1)*(y3-y1) - (x3-x1)*(y2-y1)
         d=a*x1+b*y1+c*z1
C
C        ---------------------------------------------------------------
C        DETERMINE THE UNIT VECTOR.
C
         au=a/sqrt(a*a + b*b + c*c)
         bu=b/sqrt(a*a + b*b + c*c)
         cu=c/sqrt(a*a + b*b + c*c)
C
C        ---------------------------------------------------------------
C        GET RATIO ZONING DATA.
C
         if (nwds .ge. 16) then
            call test_argument_type(1,1,16,imsgin,xmsgin,cmsgin,msgtype,
     *         nwds)
            irratio=imsgin(16)
            call test_argument_type(1,2,17,imsgin,xmsgin,cmsgin,msgtype,
     *         nwds)
            rrz=xmsgin(17)
         endif
         if (idist.eq.2.and.nwds.ge.18) then
            call test_argument_type(1,1,18,imsgin,xmsgin,cmsgin,msgtype,
     *         nwds)
            maxpenetr=imsgin(18)
         endif
C
      endif
C
      if (igeom(1:3) .eq. 'rtz') then
C
C     ******************************************************************
C     GET RAY ORIGIN LINE FOR rtz GEOMETRY
C
         call test_argument_type(6,2,7,imsgin,xmsgin,cmsgin,msgtype,nwds
     &      )
         x1=xmsgin(7)
         y1=xmsgin(8)
         z1=xmsgin(9)
         x2=xmsgin(10)
         y2=xmsgin(11)
         z2=xmsgin(12)
C
C        ---------------------------------------------------------------
C        CALCULATE THE DISTANCE BETWEEN THE TWO POINTS.
C
         dista=sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)
C
C        ---------------------------------------------------------------
C        GET RATIO ZONING DATA.
C
         if (nwds .ge. 13) then
            call test_argument_type(1,1,13,imsgin,xmsgin,cmsgin,msgtype,
     *         nwds)
            irratio=imsgin(13)
            call test_argument_type(1,1,14,imsgin,xmsgin,cmsgin,msgtype,
     *         nwds)
            rrz=xmsgin(14)
         endif
         if (idist.eq.2.and.nwds.ge.15) then
            call test_argument_type(1,1,15,imsgin,xmsgin,cmsgin,msgtype,
     *         nwds)
            maxpenetr=imsgin(15)
         endif
 
C
      endif
C
      if (igeom(1:3) .eq. 'rtp') then
C
C     ******************************************************************
C     GET RAY ORIGIN DATA FOR rtp GEOMETRY.
C
         call test_argument_type(3,2,7,imsgin,xmsgin,cmsgin,msgtype,nwds
     &      )
         x1=xmsgin(7)
         y1=xmsgin(8)
         z1=xmsgin(9)
C
C        ---------------------------------------------------------------
C        GET RATIO ZONING DATA.
C
         if (nwds .ge. 10) then
            call test_argument_type(1,1,10,imsgin,xmsgin,cmsgin,msgtype,
     *         nwds)
            irratio=imsgin(10)
            call test_argument_type(1,2,11,imsgin,xmsgin,cmsgin,msgtype,
     *         nwds)
            rrz=xmsgin(11)
         endif
         if (idist.eq.2.and.nwds.ge.12) then
            call test_argument_type(1,1,12,imsgin,xmsgin,cmsgin,msgtype,
     *         nwds)
            maxpenetr=imsgin(12)
         endif
C
      endif
C
C     ******************************************************************
C     CHECK RATIO ZONE FACTOR
C
      if (irratio.gt.0 .and. rrz.le.0) rrz=1.
C
C     ******************************************************************
C     IF EQUAL VOLUMES USED, SET DATA ACCORDING TO GEOMETRY
C
      if (irratio .eq. 2) then
         idist=4
         if (igeom .eq. 'xyz') then
            idist=1
            irratio=1
         endif
         if (igeom .eq. 'rtz') iexp=2
         if (igeom .eq. 'rtp') iexp=3
      endif
C
C     ******************************************************************
C     SET DATA IF RATIO ZONING ON THE LONGEST RAY
C
      if (irratio .eq. 3) idist=5
C
C     ******************************************************************
C    Get region information
C    CHECK THAT THIS REGION EXISTS
C    GET REGION NUMBER FOR THE REQUESTED REGION AND NO. OF REGIONS
C
      call cmo_get_name(cmo,ier)
      call mmfindbk('cregs',geom_name,ipcregs,length,ierror)
      call mmfindbk('offregdef',geom_name,ipoffregdef,length,ierror)
      call mmfindbk('ndefregs',geom_name,ipndefregs,length,ierror)
      call mmfindbk('regdef',geom_name,ipregdef,length,ierror)
      len1=icharlnf(iregnam)
      iregck=0
      do ir=1,nregs
         len2=icharlnf(cregs(ir))
         len=max(len1,len2)
         if (iregnam(1:len1) .eq. cregs(ir)(1:len)) then
            iregck=ir
            nwrdef=ndefregs(ir)
         endif
      enddo
      if (iregck .lt.1) then
         ierr2=1
         write(logmess,9001) iregnam
9001     format('  ERROR - REGION ',a8,' DOES NOT EXIST')
         call writloga('default',0,logmess,0,ierrw)
         go to 9999
      endif
C
 
C
C     ******************************************************************
C     GET TOTAL NUMBER OF SURFACES.
C
      call mmfindbk('csall',geom_name,ipcsall,length,ierror)
      call mmfindbk('istype',geom_name,ipistype,length,ierror)
      call mmfindbk('ibtype',geom_name,ipibtype,length,ierror)
      call mmfindbk('sheetnm',geom_name,ipsheetnm,length,ierror)
      call mmfindbk('surfparam',geom_name,ipsurfparam,length,ierror)
      call mmfindbk('offsparam',geom_name,ipoffsparam,length,ierror)
C
C     ******************************************************************
C     GET THE SURFACE NAMES AND OPERATORS FROM THE REGION DEFINITION
C
      is=0
      idefreg=1
      do 10 ir=1,nwrdef
         ctest=regdef(offregdef(iregck)+ir)
         idefreg=idefreg+1
         len1=icharlnf(ctest)
         if (ctest(1:len1).ne.'lt'  .and. ctest(1:len1).ne.'gt'  .and.
     &      ctest(1:len1).ne.'le'  .and. ctest(1:len1).ne.'ge'  .and.
     &      ctest(1:len1).ne.'or'  .and. ctest(1:len1).ne.'and' .and.
     &      ctest(1:len1).ne.'not' .and. ctest(1:len1).ne.'('   .and.
     &      ctest(1:len1).ne.')') then
            is=is+1
            call mmgetlen(ipisoper,length,ierr)
            if (length/KNWPN.lt. is) then
               call mmincblk('isoper',isubname,ipisoper,100,
     *                       ierr)
               call mmincblk('isurfnum',isubname,ipisurfnum,100,
     *                       ierr)
            endif
            do j=1,nsurf
              if(ctest(1:len1).eq.csall(j)(1:icharlnf(csall(j))))
     *          isurfnum(is)=j
            enddo
            isoper(is)=ctest_old
         endif
         ctest_old=ctest
 10   continue
      nsrf=is
C
C     ******************************************************************
C     GET THE SEARCH RANGE.
C
      call get_epsilon('epsilonl', srchval)
C
C     ******************************************************************
C
C     SET THE POINT INDEX BOUNDARIES.
C
      if(msgtype(3).eq.1) then
         ipt1=imsgin(3)
         ipt2=imsgin(4)
         ipt3=imsgin(5)
      else
         cpt1=cmsgin(3)
         cpt2=cmsgin(4)
         cpt3=cmsgin(5)
      endif
C
C     ******************************************************************
C
C     CHECK POINT LIMITS AND TRANSLATE TO VALID LIMITS IF NECESSARY.
C
      length=npoints
      call mmgetblk("mpary1",isubname,ipmpary1,length,1,icscode)
      mpno=length
      if(msgtype(3).eq.1) then
         call pntlimn(ipt1,ipt2,ipt3,ipmpary1,mpno,npoints,isetwd,itp1)
      elseif(msgtype(3).eq.3) then
         call pntlimc(cpt1,cpt2,cpt3,ipmpary1,mpno,npoints,isetwd,itp1)
      endif
C
      if (igeom(1:6) .eq. 'points') then
         call mmgetblk("mpary3",isubname,ipmpary3,length,1,icscode)
         mpno3=length
         if(msgtype(7).eq.1) then
            call pntlimn(ipf1,ipf2,ipf3,ipmpary3,mpno3,npoints,
     *         isetwd,itp1)
         elseif(msgtype(7).eq.3) then
            call pntlimc(cpf1,cpf2,cpf3,ipmpary3,mpno3,npoints,
     *         isetwd,itp1)
         endif
      endif
 
c.... Memory for intersection point testing arrays.
         lenivec=100*min(KVECLEN,mpno)
         call mmgetblk('xck',isubname,ipxck,lenivec,2,ics)
         call mmgetblk('yck',isubname,ipyck,lenivec,2,ics)
         call mmgetblk('zck',isubname,ipzck,lenivec,2,ics)
         call mmgetblk('indx2',isubname,ipindx2,lenivec,1,ics)
         call mmgetblk('iregno',isubname,ipiregno,lenivec,1,ics)
         call mmgetblk('isurfno',isubname,ipisurfno,lenivec,1,ics)
         call mmgetblk('iregno2',isubname,ipiregno2,lenivec,1,ics)
         call mmgetblk('isurfno2',isubname,ipisurfno2,lenivec,1,ics)
         call mmgetblk('iregloc',isubname,ipiregloc,lenivec,1,ics)
C
C     ******************************************************************
C     IF RATIO ZONING ON THE LONGEST RAY, PROCESS
C     THE LOOP TWICE.  THE FIRST TIME TO DETERMINE THE MAXIMUM NO.
C     OF POINTS PER RAY.  OTHERWISE, WE BYPASS A FIRST PASS THRU
C     THE LOOP.
C
      loopcnt=2
      drmax=0.
      if (idist .eq. 5) loopcnt=1
C
C     ******************************************************************
C     SAVE CURRENT POINT COUNT
C
      iadd=0
      lenadd=0
      icntin=icount
 
 200  continue
C
C     ******************************************************************
C     LOOP THROUGH THE USER DEFINED POINTS
C
      ckmin=0.
      ckmax=alargenumber
      do ioff=0,mpno-1,KVECLEN
         loclen=min(KVECLEN,mpno-ioff)
         do i1=1,loclen
            ip=mpary1(i1+ioff)
C
C        ---------------------------------------------------------------
C        GET THE POINT THE RAY GOES THROUGH
C
            xr2(i1)=xic(ip)
            yr2(i1)=yic(ip)
            zr2(i1)=zic(ip)
C
C        ---------------------------------------------------------------
C        DETERMINE THE RAY ORIGIN POINT FOR xyz FROM THE PLANE NORMAL
C        AND THE DISTANCE FROM xr2,yr2,zr2 TO THE PLANE.
C
            if (igeom(1:3) .eq. 'xyz') then
               sf=(a*xr2(i1) + b*yr2(i1) + c*zr2(i1) - d)/sqrt(a*a + b*b
     &            + c*c)
               xr1(i1)=xr2(i1)-au*sf
               yr1(i1)=yr2(i1)-bu*sf
               zr1(i1)=zr2(i1)-cu*sf
            endif
C
C        ---------------------------------------------------------------
C        DETERMINE THE RAY ORIGIN POINT FOR rtz FROM THE PERPENDICULAR
C
            if (igeom(1:3) .eq. 'rtz') then
               distx=((x2-x1)*(xr2(i1)-x1)+(y2-y1)*(yr2(i1)-y1)+
     &            (z2-z1)*(zr2(i1)-z1))/dista
               sf=distx/dista
               xr1(i1)=sf*x2+(1.0-sf)*x1
               yr1(i1)=sf*y2+(1.0-sf)*y1
               zr1(i1)=sf*z2+(1.0-sf)*z1
            endif
C
C        ---------------------------------------------------------------
C        IDENTICAL RAY ORIGINS FOR rtp GEOMETRY
C
            if (igeom(1:3) .eq. 'rtp') then
               xr1(i1)=x1
               yr1(i1)=y1
               zr1(i1)=z1
            endif
C
C        ---------------------------------------------------------------
C        GET THE RAY ORIGIN POINT FOR points FROM THE LIST SET
C
            if (igeom(1:6) .eq. 'points') then
               ipf=mpary3(i1+ioff)
               xr1(i1)=xic(ipf)
               yr1(i1)=yic(ipf)
               zr1(i1)=zic(ipf)
            endif
C
C        ---------------------------------------------------------------
C        STORE THE DISTANCE BETWEEN (xr1,yr1,zr1) AND (xr2,yr2,zr2)
C
C
            dist(i1)=sqrt((xr2(i1)-xr1(i1))**2+
     &         (yr2(i1)-yr1(i1))**2+(zr2(i1)-zr1(i1))**2)
 
            mint(i1)=0
 
         enddo
 
C        ---------------------------------------------------------------
C        LOOP THROUGH THE SURFACES, FIND ALL THE INTERSECTIONS FOR THE
C        RAY
C
         do is=1,nsrf
C
C           ............................................................
C           CALL getsfactv TO CALCULATE THE DISTANCE FACTORS FOR THE
C           POSITIONS ALONG THE RAYS THAT INTERSECT THE SURFACE
C           NOTE: THE CORRECT S FACTORS MUST BE POSITIVE.
C
            j=isurfnum(is)
            call getsfactv(xr1,yr1,zr1,xr2,yr2,zr2,loclen,cmo,
     *         istype(j),surfparam(offsparam(j)+1),sheetnm(j),
     *         ckmin,ckmax,srchval,sfct,nsf)
            do i1=1,loclen
               do i2=1,nsf(i1)
                  mint(i1)=mint(i1)+1
                  j=mint(i1)
                  sfact(j,i1)=sfct(i2,i1)
               enddo
            enddo
         enddo
 
C        ---------------------------------------------------------------
C        CHECK THAT MAXIMUM NUMBER OF INTERSECTIONS WITH SURFACE IS
C        NOT EXCEEDED.
C
C
         if (mint(iimax(loclen,mint,1)).ge.100) then
            ierr2=1
            write(logmess,9010)
 9010       format('ERROR:  100 OR MORE INTERSECTIONS ')
            call writloga('default',0,logmess,0,ierrw)
            go to 9999
         endif
 
C
C           ............................................................
C           SORT INTERSECTIONS INTO ASCENDING ORDER OF DISTANCE FROM
C           RAY ORIGIN.
C
         do i1=1,loclen
            if (mint(i1).ge.1) then
               call hpsort(mint(i1),sfact(1,i1))
            endif
         enddo
 
c.... Add the 'zero' s-factor in case the region where points are
c.... to be distributed is adjacent to the plane.
c.... If the first intersection is a non-negligable distance off the
c.... source, we add a 'zero' s-factor for possible creation of points
c.... between the source and the first 'real' intersection.  We tag
c.... this s=0 intersection as being 'fake' by setting LREAL=F
 
         do i1=1,loclen
            if (mint(i1).ge.1) then
               if (sfact(1,i1)*dist(i1).le.2.*srchval) then
                  lreal(i1)=.true.
               else
                  lreal(i1)=.false.
                  mint(i1)=mint(i1)+1
                  do i2=mint(i1),2,-1
                     sfact(i2,i1)=sfact(i2-1,i1)
                  enddo
                  sfact(1,i1)=0.
               endif
            endif
         enddo
 
C        ---------------------------------------------------------------
C        DELETE INTERSECTIONS THAT ARE TOO CLOSE TO OTHER INTERSECTIONS.
C
C
         do i1=1,loclen
            if (mint(i1).gt.1) then
               newmint=1
               do i2=2,mint(i1)
                  if ((sfact(i2,i1)-sfact(newmint,i1))*dist(i1).gt.2.
     &               *srchval) then
                     newmint=newmint+1
                     sfact(newmint,i1)=sfact(i2,i1)
                  endif
               enddo
               mint(i1)=newmint
            endif
         enddo
 
 
c.... Compute midpoints of intervals and load their coordinate data into
c arrays.
 
         ivec=0
         do i1=1,loclen
            if (mint(i1).ge.2) then
               do i2=1,mint(i1)-1
                  s=0.5*(sfact(i2,i1)+sfact(i2+1,i1))
                  ivec=ivec+1
                  xck(ivec)=s*xr2(i1)+(1.0-s)*xr1(i1)
                  yck(ivec)=s*yr2(i1)+(1.0-s)*yr1(i1)
                  zck(ivec)=s*zr2(i1)+(1.0-s)*zr1(i1)
               enddo
            endif
         enddo
 
C
C           ............................................................
C           Check midpoints for membership in the region definition.
C
         call chkregv(xck,yck,zck,ivec,srchval,'region',
     &      regdef(offregdef(iregck)+1),ndefregs(iregck),
     &      iregloc,ierr)
C
C        ---------------------------------------------------------------
C        IF iregloc=2 FOR MIDPOINTS, THE POINT IS 'ON'
C        THE SURFACE OF THE REGION AND NEEDS TO BE RETESTED WITH getregv
c .
C        IF A TESTED POINT QUALIFIES AS BEING PART OF THE REGION, ITS
C        iregloc VALUE IS CHANGED TO '1', SO THAT IT WILL BE WRITTEN
C        INTO THE CMO.
C
         ivec2=0
         do ii=1,ivec
            if (iregloc(ii).eq.2) then
               ivec2=ivec2+1
               xck(ivec2)=xck(ii)
               yck(ivec2)=yck(ii)
               zck(ivec2)=zck(ii)
               indx2(ivec2)=ii
            endif
         enddo
         if (ivec2.gt.0) then
            call getregv(xck,yck,zck,ivec2,srchval,'region',
     &        iregck,
     &        iregno2,isurfno2,ierr)
            do ii=1,ivec2
               if (iregno2(ii).eq.iregck) then
                  iregloc(indx2(ii))=1
               endif
            enddo
         endif
 
c.... From the midpoint membership information, for each ray, create
c.... distinct unconnected intervals that belong to the region.
 
         ii=0
         do i1=1,loclen
            if (mint(i1).ge.2) then
               icurrmin=1
               icurrmax=0
               numint=0
               do i2=2,mint(i1)
                  ii=ii+1
                  if (iregloc(ii).eq.1) then
                     icurrmax=i2
                  else
                     if (icurrmax.eq.0) then
                        icurrmin=i2
                     else
                        numint=numint+1
                        sfact(2*numint-1,i1)=sfact(icurrmin,i1)
                        sfact(2*numint,i1)=sfact(icurrmax,i1)
                        icurrmin=i2
                        icurrmax=0
                     endif
                  endif
               enddo
               if (icurrmax.ne.0) then
                  numint=numint+1
                  sfact(2*numint-1,i1)=sfact(icurrmin,i1)
                  sfact(2*numint,i1)=sfact(icurrmax,i1)
               endif
               mint(i1)=2*numint
            endif
         enddo
 
C
C        ---------------------------------------------------------------
C        Test interval ends for membership in region.
C
         ivec=0
         do i1=1,loclen
            if (mint(i1).ge.2) then
               do i2=1,mint(i1)
                  s=sfact(i2,i1)
                  ivec=ivec+1
                  xck(ivec)=s*xr2(i1)+(1.0-s)*xr1(i1)
                  yck(ivec)=s*yr2(i1)+(1.0-s)*yr1(i1)
                  zck(ivec)=s*zr2(i1)+(1.0-s)*zr1(i1)
               enddo
            endif
         enddo
         call getregv(xck,yck,zck,ivec,srchval,'region',
     &      iregck,
     &      iregno,isurfno,ierr)
 
C
C        ...............................................................
C        Obtain sufficient memory for ``add'' arrays if necessary.
C
         need=iadd
 
c.... If we are distributing NPTDIST points in the interiors of
c.... intervals, then an upper bound on points added is
c.... (NPTDIST+3)*<number of intervals>.  We get the '3', since
c.... (a) the endpoints of each interval could get points,
c.... (b) the midpoint of any interval will get a point if
c....     no other points are added in the interior of the interval.
 
         if (idist.eq.1 .or. idist.eq.4 .or.idist.eq.5) then
            do i1=1,loclen
               numint=mint(i1)/2
               need=need+3*numint+nptdist*numint
            enddo
 
c.... If we are distributing points at a spacing of XPTDIST, up
c.... to a maximum of MAXPENETR points per interval, then
c.... an upper bound on points added is
c.... MIN( <Total length of ray>/XPTDIST, MAXPENETR*<no. of intervals> )
c.... + 3*<number of intervals).
c.... The reasoning for the last term is given by (a),(b) above.
c.... If MAXPENETR=-1, that signifies no limit on points per interval.
c.... If MAXPENETR=0, no. of points is simply number of intervals.  (I.e.,
c.... one point on each 'entry' interface.)
 
         elseif (idist.eq.2) then
            if (maxpenetr.gt.0) then
               do i1=1,loclen
                  if (mint(i1).gt.1) then
                     numint=mint(i1)/2
                     need=need+3*numint+min(nint(
     &                  (sfact(mint(i1),i1)-sfact(1,i1))*dist(i1)
     &                  /xptdist),maxpenetr*numint)
                  endif
               enddo
            elseif (maxpenetr.eq.0) then
               do i1=1,loclen
                  numint=mint(i1)/2
                  need=need+numint
               enddo
            else
               do i1=1,loclen
                  if (mint(i1).gt.1) then
                     numint=mint(i1)/2
                     need=need+3*numint+
     &                  (sfact(mint(i1),i1)-sfact(1,i1))*dist(i1)
     &                  /xptdist
                  endif
               enddo
            endif
 
c.... If we are distributing points on the interfaces only, a limit
c.... on the maximum number of points added is 2*<no. of intervals>.
 
         elseif (idist.eq.3) then
            do i1=1,loclen
               need=need+mint(i1)
            enddo
         endif
 
         if (need.gt.lenadd) then
            if (lenadd.eq.0) then
               lenadd=max(1000,need)
               call mmgetblk('xadd',isubname1,ipxadd,lenadd,2,ics)
               call mmgetblk('yadd',isubname1,ipyadd,lenadd,2,ics)
               call mmgetblk('zadd',isubname1,ipzadd,lenadd,2,ics)
            else
               nincr=max(1000,need-lenadd)
               lenadd=lenadd+nincr
               call mmincblk('xadd',isubname1,ipxadd,nincr,ics)
               call mmincblk('yadd',isubname1,ipyadd,nincr,ics)
               call mmincblk('zadd',isubname1,ipzadd,nincr,ics)
            endif
         endif
 
c.... Loop through intervals, distributing points.
 
C        ...............................................................
C        FOR EACH RAY, SOLVE FOR VOLUME POINT DISTRIBUTION
C        (IE., DEFINE rstrt AND dr).
C
         ivec=0
         do 100 i1=1,loclen
 
            if (mint(i1).ge.2) then
 
               smin=sfact(1,i1)
               smax=sfact(mint(i1),i1)
C
C        ...............................................................
C        DETERMINE START AND FINISH POINTS
C
               xstrt=smin*xr2(i1)+(1.0-smin)*xr1(i1)
               ystrt=smin*yr2(i1)+(1.0-smin)*yr1(i1)
               zstrt=smin*zr2(i1)+(1.0-smin)*zr1(i1)
               xfin=smax*xr2(i1)+(1.0-smax)*xr1(i1)
               yfin=smax*yr2(i1)+(1.0-smax)*yr1(i1)
               zfin=smax*zr2(i1)+(1.0-smax)*zr1(i1)
C
C        ---------------------------------------------------------------
C        DETERMINE BEGINING AND ENDING RADII, INCREMENTAL DISTANCE OR
C        NO. OF POINTS TO ADD
C
               rmin=sqrt((xstrt-xr1(i1))**2 + (ystrt-yr1(i1))**2 +
     &            (zstrt-zr1(i1))**2)
               rmax=sqrt((xfin-xr1(i1))**2 + (yfin-yr1(i1))**2 +
     &            (zfin-zr1(i1))**2)
C
C        ...............................................................
C        IF NO. OF POINTS ENTERED, CALL rzstrat TO SET UP RATIO ZONING
C        ALSO IF RATIO ZONING ON THE LONGEST RAY.
C
               if (idist.eq.1 .or. (idist.eq.5.and.loopcnt.eq.1) ) then
                  nr=nptdist+2
                  irz=1
                  call rzstrat(nr,rmin,rmax,irz,irratio,rrz,dr
     &               ,rstrt)
               endif
C
C        ...............................................................
C        IF INCREMENTAL DISTANCE ENTERED, SET UP PARAMETERS
C
               if (idist .eq. 2) then
                  dr=xptdist
                  rstrt=rmin-dr
                  rrz=1.
               endif
C
C        ...............................................................
C        IF EQUAL VOLUMES, SET UP APPROPRIATE RATIO ZONING
C
               if (idist .eq. 4) then
                  nr=nptdist+2
                  rstrt=rmin
                  sumf=0.
                  do i=1,nr-1
                     sumf=sumf + rrz**(i-1)
                  enddo
                  vol1=(rmax**iexp - rmin**iexp)/sumf
               endif
 
C
C        ...............................................................
C        KEEP TRACK OF MAXIMUM dr FOR RATIO ZONING ON THE LONGEST RAY.
C
               if (loopcnt.eq.1) then
                  drmax=max(drmax,dr)
                  goto 100
               endif
C
C        ...............................................................
C        RESET dr AND rstrt FOR RATIO ZONING OVER LONGEST RAY
C
               if (idist .eq. 5) then
                  dr=drmax
                  rstrt=rmin-dr
               endif
 
               ivolseq=0
               r=rstrt
               ddr=dr
 
               do i2=1,mint(i1)/2
 
c.... Nearer endpoint of interval I2.  Add if part of region definition
c.... or if specified by surfpts (idist.eq.3).
 
                  ivec=ivec+1
                  if (idist.ne.3.and.iregno(ivec).eq.iregck.or.
     &               idist.eq.3.and.(
     &               inout(1:1).eq.'i' .or. inout(1:2).eq.'in' .or.
     &               inout(1:6).eq.'inside' .or. inout(1:1).eq.'b'
     &               .or.inout(1:4).eq.'both')) then
 
c....  The following 'if' test has been disabled.  This means that the
c....  origin plane, line, or point is always considered to be an
c....  interface for purposes of point creation.  In particular,
c....  points will automatically be deposited at the centers of spheres
c....  and the center axes of cylinders.
 
c$$$c.... However, do not add if it's the entry point of the first interval
c$$$c.... and this point was artificially created (LREAL=F and first
c$$$c.... s-factor is zero).
c$$$
c$$$                     if ((i2.gt.1).or.
c$$$     &                  (sfact(1,i1).ne.zero.or.lreal(i1))) then
                        s=sfact(2*i2-1,i1)
                        iadd=iadd+1
                        xadd(iadd)=s*xr2(i1)+(1.0-s)*xr1(i1)
                        yadd(iadd)=s*yr2(i1)+(1.0-s)*yr1(i1)
                        zadd(iadd)=s*zr2(i1)+(1.0-s)*zr1(i1)
c$$$                     endif
 
                  endif
 
                  ivolinterval=0
 
c.... For surfpts or for maxpenetr=0, there are no volume points.
 
                  if (idist.eq.3.or.
     &               (idist.eq.2.and.maxpenetr.eq.0)) goto 500
 
                  rlast=dist(i1)*sfact(2*i2-1,i1)
                  rnext=dist(i1)*sfact(2*i2,i1)
 
c.... Advance volume point distribution until it exceeds the
c.... preceding intersection point.
 
                  if (idist.eq.2) then
 
c.... If ptdist real, make sure points are aligned with entry point of interval.
 
                     r=rlast
 
c.... Spacing reset unnecessary, since ratio spacing not currently
c.... allowed with ptdist real.
 
c....                ddr=dr
 
                  endif
                  do while (r-srchval.lt.rlast)
                     ivolseq=ivolseq+1
                     if (idist .ne. 4) then
                        r=r+ddr
                        ddr=ddr*rrz
                     else
                        r=(r**iexp + rrz**(ivolseq-1)*vol1)**(1.d0/iexp)
                     endif
                  enddo
 
c$$$c.... If volume distribution now exceeds pending intersection
c$$$c.... point, insert ``non-distribution'' volume point.  That is, unless
c$$$c.... we have regnpts/../0/..
c$$$
c$$$                  if (.not.(idist.eq.1.and.nptdist.eq.0)) then
c$$$                     if (r+srchval.gt.rnext) then
c$$$                        iadd=iadd+1
c$$$                        s=0.5*(sfact(2*i2-1,i1)+sfact(2*i2,i1))
c$$$                        xadd(iadd)=s*xr2(i1)+(1.0-s)*xr1(i1)
c$$$                        yadd(iadd)=s*yr2(i1)+(1.0-s)*yr1(i1)
c$$$                        zadd(iadd)=s*zr2(i1)+(1.0-s)*zr1(i1)
c$$$                     endif
c$$$                  endif
 
c.... Insert ``distribution'' volume points.
 
                  ivolinterval=0
                  do while(r+srchval.le.rnext)
                     ivolseq=ivolseq+1
                     if (maxpenetr.eq.-1.or.
     &                  ivolinterval.lt.maxpenetr) then
                        ivolinterval=ivolinterval+1
                        iadd=iadd+1
                        sfr=r/dist(i1)
                        xadd(iadd)=xr1(i1)+sfr*(xr2(i1)-xr1(i1))
                        yadd(iadd)=yr1(i1)+sfr*(yr2(i1)-yr1(i1))
                        zadd(iadd)=zr1(i1)+sfr*(zr2(i1)-zr1(i1))
                     endif
                     if (idist .ne. 4) then
                        r=r+ddr
                        ddr=ddr*rrz
                     else
                        r=(r**iexp + rrz**(ivolseq-1)*vol1)**(1.d0/iexp)
                     endif
                  enddo
 
 500              continue
 
c.... Further endpoint of interval I2.  Add if part of region definition
c.... or if specified by surfpts (idist.eq.3).  However, do not add if
c.... using penetration control (maxpenetr.ge.0) and number of
c.... volume points put down (IVOLINTERVAL) already equals MAXPENETR.
 
                  ivec=ivec+1
                  ladd=.false.
                  ladd = ladd .or.
     &               ( idist.eq.3 .and.
     &               (inout(1:1).eq.'o' .or. inout(1:3).eq.'out' .or.
     &               inout(1:7).eq.'outside' .or. inout(1:1).eq.'b'
     &               .or.inout(1:4).eq.'both') )
                  ladd = ladd .or.
     &               ( idist.eq.2 .and.
     &               iregno(ivec).eq.iregck .and.
     &               (maxpenetr.eq.-1.or.ivolinterval.lt.maxpenetr) )
                  ladd = ladd .or.
     &               ( idist.ne.2.and.idist.ne.3 .and.
     &               iregno(ivec).eq.iregck )
                  if (ladd) then
                     s=sfact(2*i2,i1)
                     iadd=iadd+1
                     xadd(iadd)=s*xr2(i1)+(1.0-s)*xr1(i1)
                     yadd(iadd)=s*yr2(i1)+(1.0-s)*yr1(i1)
                     zadd(iadd)=s*zr2(i1)+(1.0-s)*zr1(i1)
                  endif
               enddo
            endif
 100     continue
      enddo
C
C     ******************************************************************
C     REPROCESS LOOP IF NECESSARY
C
      if (loopcnt .eq. 1) then
         loopcnt=2
         go to 200
      endif
C
C     ******************************************************************
C     ADD NEW POINTS TO CMO, RELEASING ONE (OF TWO) PARTITIONS TO
C     PREVENT A POSSIBLE UNNECESSARY 'OUT OF MEMORY' ERROR.
C
      call mmrelprt(isubname,icscode)
      ireleased=1
 
      npoints=npoints+iadd
      call cmo_set_info('nnodes',cmo,npoints,1,1,ierror)
      call cmo_newlen(cmo,ierror)
      call cmo_get_info('xic',cmo,ipxic,ilen,ityp,ierr)
      call cmo_get_info('yic',cmo,ipyic,ilen,ityp,ierr)
      call cmo_get_info('zic',cmo,ipzic,ilen,ityp,ierr)
 
c.... Refresh 'add' array pointers.
      call mmgetpr('xadd',isubname1,ipxadd,ics)
      call mmgetpr('yadd',isubname1,ipyadd,ics)
      call mmgetpr('zadd',isubname1,ipzadd,ics)
 
      do k=1,iadd
         xic(icount+k)=xadd(k)
         yic(icount+k)=yadd(k)
         zic(icount+k)=zadd(k)
      enddo
      icount=icount+iadd
 
C     ******************************************************************
C     PRINT OUT THE NUMBER OF POINTS GENERATED IN THE REGION
C
      write(logmess,6000) icntin+1,icount,iregnam
 6000 format('  REGNPTS GENERATED POINTS ',i9,' TO ',i9,
     &   ' FOR REGION ',a8)
      call writloga('default',0,logmess,0,ierrw)
C
C     ******************************************************************
C     SET UP THE CFT IMMUNE STATEMENT FOR DDT
C
      goto 9999
 9999 continue
C
C     RELEASE TEMPORARY MEMORY
C
      call mmrelprt(isubname1,icscode)
      if (ireleased.eq.0) call mmrelprt(isubname,icscode)
C
c  reset problem size to account for new nodes
c
      call setsize()
      return
      end
 
*dk,hpsort
      SUBROUTINE hpsort(n,ra)
C
C
C#######################################################################
C
C     PURPOSE -
C
C     THIS IS THE NUMERICAL RECIPES ROUTINE FOR SORTING
C     AN ARRAY USING THE 'HEAP SORT'.
C
C
C     INPUT ARGUMENTS -
C
C        n - NO. OF ELEMENTS TO SORT INTO ASCENDING ORDER.
C        ra - REAL*8 ARRAY TO BE SORTED.
C
C
C
C     OUTPUT ARGUMENTS -
C
C        ra - SORTED REAL*8 ARRAY.
C
C
C     CHANGE HISTORY -
C
C        $Log: regnpts.f,v $
C        Revision 2.00  2007/11/09 20:04:01  spchu
C        Import to CVS
C
C
C#######################################################################
C
 
      implicit none
 
      INTEGER n
      REAL*8 ra(n)
      INTEGER i,ir,j,l
      REAL*8 rra
      if (n.lt.2) return
      l=n/2+1
      ir=n
10    continue
        if(l.gt.1)then
          l=l-1
          rra=ra(l)
        else
          rra=ra(ir)
          ra(ir)=ra(1)
          ir=ir-1
          if(ir.eq.1)then
            ra(1)=rra
            return
          endif
        endif
        i=l
        j=l+l
20      if(j.le.ir)then
          if(j.lt.ir)then
            if(ra(j).lt.ra(j+1))j=j+1
          endif
          if(rra.lt.ra(j))then
            ra(i)=ra(j)
            i=j
            j=j+j
          else
            j=ir+1
          endif
        goto 20
        endif
        ra(i)=rra
      goto 10
      END
C  (C) Copr. 1986-92 Numerical Recipes Software $!{.9s21-.
